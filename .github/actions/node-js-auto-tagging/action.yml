name: node-js-auto-tagging
description: node-js-auto-tagging

# Composite action that reads package.json, enforces tag ordering, and emits
# the next semantic version so workflows can update files and create tags safely.

inputs:
  package-json-path:
    description: "Path to package.json"
    default: "package.json"
    required: false

outputs:
  version:
    description: "Version read from package.json (x.y.z)"
    value: ${{ steps.read_version.outputs.version }}
  version_with_build:
    description: "Full version read from package.json (x.y.z+build)"
    value: ${{ steps.read_version.outputs.version_with_build }}
  build_metadata:
    description: "Build metadata portion that followed the semver (if any)"
    value: ${{ steps.read_version.outputs.build_metadata }}
  new_version:
    description: "Next patch version (x.y.(z+1))"
    value: ${{ steps.patch_version.outputs.new_version }}
  new_version_with_build:
    description: "Next patch version, preserving build metadata if it existed"
    value: ${{ steps.patch_version.outputs.new_version_with_build }}

runs:
  using: "composite"
  steps:
    - name: Read version from package.json
      id: read_version
      shell: bash
      # Ensures the declared version exists and is well-formed.
      run: |
        set -euo pipefail

        FILE="${{ inputs.package-json-path }}"

        if [ ! -f "$FILE" ]; then
          echo "::error::package.json not found at: $FILE"
          exit 1
        fi

        if ! PACKAGE_VERSION=$(node -e "const fs=require('fs');const path=process.argv[1];try{const pkg=JSON.parse(fs.readFileSync(path,'utf8'));const version=(pkg.version ?? '').toString().trim();if(!version){process.exit(3);}console.log(version);}catch(err){console.error(err.message);process.exit(2);}" "$FILE"); then
          echo "::error::Failed to parse package.json or missing version field."
          exit 1
        fi

        RAW_VERSION="$PACKAGE_VERSION"
        if echo "$RAW_VERSION" | grep -Eq '^[Vv]'; then
          RAW_VERSION="${RAW_VERSION:1}"
        fi

        BASE_VERSION="$RAW_VERSION"
        BUILD_METADATA=""
        if echo "$RAW_VERSION" | grep -q '+'; then
          BASE_VERSION="${RAW_VERSION%%+*}"
          BUILD_METADATA="${RAW_VERSION#*+}"
        fi

        if [ -z "$BASE_VERSION" ]; then
          echo "::error::Version string is empty after parsing"
          exit 1
        fi

        # Basic semver sanity check
        if ! echo "$BASE_VERSION" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$'; then
          echo "::error::Version '$BASE_VERSION' is not in proper x.y.z format"
          exit 1
        fi

        if [ -n "$BUILD_METADATA" ]; then
          echo "::notice::package.json version: $BASE_VERSION+$BUILD_METADATA"
          echo "- [x] Read version from $FILE: $BASE_VERSION+$BUILD_METADATA" >> $GITHUB_STEP_SUMMARY
        else
          echo "::notice::package.json version: $BASE_VERSION"
          echo "- [x] Read version from $FILE: $BASE_VERSION" >> $GITHUB_STEP_SUMMARY
        fi

        echo "version=$BASE_VERSION" >> "$GITHUB_OUTPUT"
        echo "version_with_build=$RAW_VERSION" >> "$GITHUB_OUTPUT"
        echo "build_metadata=$BUILD_METADATA" >> "$GITHUB_OUTPUT"

    - name: Ensure no later major / major.minor tag exists
      id: check_tags
      shell: bash
      # Fail fast if git tags already advanced past the package.json version.
      run: |
        VERSION='${{ steps.read_version.outputs.version }}'
        MAJOR=$(echo "$VERSION" | cut -d. -f1)
        MINOR=$(echo "$VERSION" | cut -d. -f2)
        PATCH=$(echo "$VERSION" | cut -d. -f3)

        echo "Checking tags against version: $MAJOR.$MINOR.$PATCH"

        git fetch --tags --force >/dev/null 2>&1 || true

        ALL_TAGS=$(git tag --list)
        if [ -z "$ALL_TAGS" ]; then
          echo "::notice::No tags in repo → skipping verification."
          exit 0
        fi

        SEMVER_TAGS=""
        for t in $ALL_TAGS; do
          base="$t"
          base="${base#v}"   # strip leading 'v' if present
          # only keep full semver tags
          if echo "$base" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            SEMVER_TAGS="$SEMVER_TAGS $base"
          fi
        done

        if [ -z "$SEMVER_TAGS" ]; then
          echo "::notice::No semver style tags (x.y.z or vx.y.z) found → skipping verification."
          exit 0
        fi

        HIGHEST_MAJOR=0
        HIGHEST_MAJOR_MINOR=""

        for v in $SEMVER_TAGS; do
          t_major=$(echo "$v" | cut -d. -f1)
          t_minor=$(echo "$v" | cut -d. -f2)

          # track highest major in repo
          if [ "$t_major" -gt "$HIGHEST_MAJOR" ]; then
            HIGHEST_MAJOR="$t_major"
          fi

          # track highest minor for same major as the declared version
          if [ "$t_major" -eq "$MAJOR" ]; then
            pair="$t_major.$t_minor"
            if [ -z "$HIGHEST_MAJOR_MINOR" ] || \
              [ "$(printf '%s\n' "$pair" "$HIGHEST_MAJOR_MINOR" | sort -V | tail -n1)" = "$pair" ]; then
              HIGHEST_MAJOR_MINOR="$pair"
            fi
          fi
        done

        echo "Highest major in tags: $HIGHEST_MAJOR"
        if [ -n "$HIGHEST_MAJOR_MINOR" ]; then
          echo "Highest major.minor for same major: $HIGHEST_MAJOR_MINOR"
        fi

        # Fail if there is a later major than in package.json
        if [ "$HIGHEST_MAJOR" -gt "$MAJOR" ]; then
          echo "::error::Repo already has a later major release ($HIGHEST_MAJOR.x.x) than package.json ($MAJOR.$MINOR.$PATCH)."
          exit 1
        fi

        # Fail if there is a later minor (for same major) than in package.json
        if [ -n "$HIGHEST_MAJOR_MINOR" ]; then
          tag_minor=$(echo "$HIGHEST_MAJOR_MINOR" | cut -d. -f2)
          if [ "$tag_minor" -gt "$MINOR" ]; then
            echo "::error::Repo already has a later minor release ($HIGHEST_MAJOR_MINOR.x) than package.json ($MAJOR.$MINOR.$PATCH)."
            exit 1
          fi
        fi

        echo "- [x] Tag verification passed successfully" >> $GITHUB_STEP_SUMMARY
        echo "::notice::Tag verification passed successfully."

    - name: Increase patch version
      id: patch_version
      shell: bash
      # Compute the next patch (preserving build metadata) for downstream use.
      run: |
        VERSION='${{ steps.read_version.outputs.version }}'
        BUILD='${{ steps.read_version.outputs.build_metadata }}'
        IFS=. read MAJOR MINOR PATCH <<< "$VERSION"

        NEW_PATCH=$((PATCH + 1))
        NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"

        FULL_VERSION="$NEW_VERSION"
        if [ -n "$BUILD" ]; then
          FULL_VERSION="$NEW_VERSION+$BUILD"
        fi

        echo "::notice::new patch version: $FULL_VERSION"
        echo "- [x] New Tag version: $FULL_VERSION" >> $GITHUB_STEP_SUMMARY        
        echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
        echo "new_version_with_build=$FULL_VERSION" >> "$GITHUB_OUTPUT"
